{
    "s-read": {
        "function": "s-read(filename)",
        "description": "Play the contents of a sound file named by filename. The s-read function is used to read the file, and unless filename specifies an absolute path or starts with “.”, it will be read from *default-sf-dir*."
    },
    "make-line": {
        "function": "make-line(items, for: for, name: name, trace: trace) [SAL]",
        "description": "Make a line pattern that iterates over items. The default period length is the length of items. As with make-cycle, items may be a pattern. (See above for a description of the optional parameters.)"
    },
    "make-random": {
        "function": "make-random(items, for: for, name: name, trace: trace) [SAL]",
        "description": "Make a random pattern that selects from items. Any (or all) element(s) of items may be lists of the following form: (value :weight weight :min mincount :max maxcount), where value is the item (or pattern) to be generated, weight is the (optional) relative probability of selecting this item, mincount is the (optional) minimum number of repetitions when this item is selected, and maxcount is the (optional) maximum number of repetitions allowed before selecting some other item. The default period length is the length of items. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period."
    },
    "make-heap": {
        "function": "make-heap(items, for: for, max: max, name: name, trace: trace)",
        "description": "Generate items randomly from list without replacement. If max is 1, the first element of a new period will not be the same as the last element of the previous period, avoiding repetition. The default value of max is 2, meaning repetition is allowed. The period length is the length of items. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period."
    },
    "make-palindrome": {
        "function": "make-palindrome(items, elide: elide, for: for, name: name, trace: trace)",
        "description": "Generate items from list alternating in-order and reverse-order sequencing. The keyword parameter elide can have the values :first, :last, t, or nil to control repetition of the first and last elements. The elide parameter can also be a pattern, in which case it is evaluated every period. One period is one complete forward and backward traversal of the list. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period."
    },
    "make-accumulation": {
        "function": "make-accumulation(items, name: name, trace: trace) [SAL]",
        "description": "Return the prefixes of items, e.g. the first element followed by the first and second elements, then the first three, until the entire list is returned. The period length is (n2 + n) / 2 where n is the length of items. If items is a pattern, a period from that pattern becomes the list from which items are generated, and a new list is generated every period. Note that this is similar in name but different from make-accumulate."
    },
    "make-copier": {
        "function": "make-copier(sub-pattern, repeat: repeat, merge: merge, for: for, name: name, trace: trace) [SAL]",
        "description": "Generate a period from sub-pattern and repeat it repeat times. If merge is false (the default), each repetition of a period from sub-pattern results in a period by default. If merge is true (non-null), then all repeat repetitions of the period are merged into one result period by default. If the for: keyword is used, the same items are generated, but the items are grouped into periods determined by the for: parameter. If the for: parameter is a pattern, it is evaluated every result period. The repeat and merge values may be patterns that return a repeat count and a boolean value, respectively. If so, these patterns are evaluated initially and after each repeat copies are made (independent of the for: keyword parameter, if any). The repeat value returned by a pattern can also be negative. A negative number indicates how many periods of sub-pattern to skip. After skipping these patterns, new repeat and merge values are generated."
    },
    "make-accumulate": {
        "function": "make-accumulate(sub-pattern, for: for, max: maximum, min: minimum, name: name, trace: trace) [SAL]",
        "description": "Keep a running sum of numbers generated by sub-pattern. The default period lengths match the period lengths from sub-pattern. If maximum (a pattern or a number) is specified, and the running sum exceeds maximum, the running sum is reset to maximum. If minimum (a pattern or a number) is specified, and the running sum falls below minimum, the running sum is reset to minimum. If minimum is greater than maximum, the running sum will be set to one of the two values. Minimum and maximum patterns are reevaluated every cycle. Note that this is similar in name but not in function to make-accumulation."
    },
    "make-sum": {
        "function": "make-sum(x, y, for: for, name: name, trace: trace) [SAL]",
        "description": "Form sums of items (which must be numbers) from pattern x and pattern or number y. The default period lengths match the period lengths from x."
    },
    "make-product": {
        "function": "make-product(x, y, for: for, name: name, trace: trace) [SAL]",
        "description": "Form products of items (which must be numbers) from pattern x and pattern or number y. The default period lengths match the period lengths from x."
    },
    "make-eval": {
        "function": "make-eval(expr, for: for, name: name, trace: trace) [SAL]",
        "description": "Evaluate expr to generate each item. If expr is a pattern, each item is generated by getting the next item from expr and evaluating it. Note that expr is evaluated as a Lisp expression, which is a list consisting of the function name followed by parameter expressions (which may also be lists). In the simplest case (recommended), create a SAL function with no parameters that performs the computation. For example, to create a pattern in SAL that calls the parameterless function rrandom, write make-eval({rrandom}). In SAL, {rrandom} creates a list with the (unevaluated) symbol rrandom, equivalent to list(quote(rrandom))."
    },
    "make-length": {
        "function": "make-length(pattern, length-pattern, name: name, trace: trace) [SAL]",
        "description": "Make a pattern of class length-class that regroups items generated by a pattern according to pattern lengths given by length-pattern. Note that length-pattern is not optional: There is no default pattern length and no for: keyword."
    },
    "make-window": {
        "function": "make-window(pattern, length-pattern, skip-pattern, name: name, trace: trace) [SAL]",
        "description": "Make a pattern of class window-class that regroups items generated by a pattern according to pattern lengths given by length-pattern and where the period advances by the number of items given by skip-pattern. Note that length-pattern is not optional: There is no default pattern length and no for: keyword."
    },
    "make-markov": {
        "function": "make-markov(rules, past: past, produces: produces, for: for, name: name, trace: trace) [SAL]",
        "description": "Generate a sequence of items from a Markov process. The rules parameter is a list of rules where each rule has the form: (prev1 prev2 ... prevn -> next1 next2 ... nextn) where prev1 through prevn represent a sequence of most recent (past) states. The symbol * is treated specially: it matches any previous state. If prev1 through prevn (which may be just one state as in the example above) match the previously generated states, this rule applies. Note that every rule must specify the same number of previous states; this number is known as the order of the Markov model. The first rule in rules that applies is used to select the next state. If no rule applies, the next state is NIL (which is a valid state that can be used in rules). Assuming a rule applies, the list of possible next states is specified by next1 through nextn. Notice that these are alternative choices for the next state, not a sequence of future states, and each rule can have any number of choices. Each choice may be the state itself (a symbol or a number), or the choice may be a list consisting of the state and a weight. The weight may be given by a pattern, in which case the next item of the pattern is obtained every time the rule is applied. For example, this rules says that if the previous states were A and B, the next state can be A with a weight of 0.5 or C with an implied weight of 1: (A B -> (A 0.5) C). The default length of the period is the length of rules. The past parameter must be provided. It is a list of states whose length matches the order of the Markov model. The keyword parameter produces may be used to map from state symbols or numbers to other values or patterns. The parameter is a list of alternating symbols and values. For example, to map A to 69 and B to 71, use list(quote(a), 69, quote(b), 71). You can also map symbols to patterns, for example list(quote(a), make-cycle({57 69}), quote(b), make-random({59 71})). The next item of the pattern is is generated each time the Markov model generates the corresponding state. Finally, the produces keyword can be :eval, which means to evaluate the Markov model state. This could be useful if states are Nyquist global variables such as C4, CS4, D4, ]..., which evaluate to numerical values (60, 61, 62, ...."
    },
    "markov-create-rules": {
        "function": "markov-create-rules(sequence, order [, generalize]) [SAL]",
        "description": "Generate a set of rules suitable for the make-markov function. The sequence is a “typical” sequence of states, and order is the order of the Markov model. It is often the case that a sample sequence will not have a transition from the last state to any other state, so the generated Markov model can reach a “dead end” where no rule applies. This might lead to an infinite stream of NIL's. To avoid this, the optional parameter generalize can be set to t (true), indicating that there should be a fallback rule that matches any previous states and whose future states are weighted according to their frequency in sequence. For example, if sequence contains 5 A's, 5 B's and 10 G's, the default rule will be (* -> (A 5) (B 5) (G 10)). This rule will be appended to the end so it will only apply if no other rule does."
    },
    "linear-dist": {
        "function": "linear-dist(g) [SAL]",
        "description": "Return a FLONUM value from a linear distribution, where the probability of a value decreases linearly from zero to g which must be greater than zero. (See Figure 7.) The linear distribution is useful for generating for generating time and pitch intervals."
    },
    "exponential-dist": {
        "function": "exponential-dist(delta [, high]) [SAL]",
        "description": "Return a FLONUM value from an exponential distribution. The initial downward slope is steeper with larger values of delta, which must be greater than zero. (See Figure 8. The optional high parameter puts an artificial upper bound on the return value. The exponential distribution generates values greater than 0, and can be used to generate time intervals. Natural random intervals such as the time intervals between the release of atomic particles or the passing of yellow volkswagons in traffic have exponential distributions. The exponential distribution is memory-less: knowing that a random number from this distribution is greater than some value (e.g. a note duration is at least 1 second) tells you nothing new about how soon the note will end. This is a continuous distribution, but geometric-dist (described below) implements the discrete form."
    },
    "gamma-dist": {
        "function": "gamma-dist(nu [, high]) [SAL]",
        "description": "Return a FLONUM value from a Gamma distribution. The value is greater than zero, has a mean of nu (a FIXNUM greater than zero), and a mode (peak) of around nu - 1. The optional high parameter puts an artificial upper bound on the return value."
    },
    "bilateral-exponential-dist": {
        "function": "bilateral-exponential-dist(xmu, tau [, low, high]) [SAL]",
        "description": "Returns a FLONUM value from a bilateral exponential distribution, where xmu is the center of the double exponential and tau controls the spread of the distribution. A larger tau gives a wider distribution (greater variance), and tau must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively. This distribution is similar to the exponential, except it is centered at 0 and can output negative values as well. Like the exponential, it can be used to generate time intervals; however, it might be necessary to add a lower bound so as not to compute a negative time interval."
    },
    "cauchy-dist": {
        "function": "cauchy-dist(tau [, low, high]) [SAL]",
        "description": "Returns a FLONUM from the Cauchy distribution, a symmetric distribution with a high peak at zero and a width (variance) that increases with parameter tau, which must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively."
    },
    "hyperbolic-cosine-dist": {
        "function": "hyperbolic-cosine-dist([low, high]) [SAL]",
        "description": "Returns a FLONUM value from the hyperbolic cosine distribution, a symmetric distribution with its peak at zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively."
    },
    "logistic-dist": {
        "function": "logistic-dist(alpha, beta [, low, high]) [SAL]",
        "description": "Returns a FLONUM value from the logistic distribution, which is symmetric about the mean. The alpha parameter primarily affects dispersion (variance), with larger values resulting in values closer to the mean (less variance), and the beta parameter primarily influences the mean. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively."
    },
    "arc-sine-dist": {
        "function": "arc-sine-dist() [SAL]",
        "description": "Returns a FLONUM value from the arc sine distribution, which outputs values between 0 and 1. It is symmetric about the mean of 1/2, but is more likely to generate values closer to 0 and 1."
    },
    "gaussian-dist": {
        "function": "gaussian-dist(xmu, sigma [, low, high]) [SAL]",
        "description": "Returns a FLONUM value from the Gaussian or Gauss-Laplace distribution, a linear function of the normal distribution. It is symmetric about the mean of xmu, with a standard deviation of sigma, which must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively."
    },
    "beta-dist": {
        "function": "beta-dist(a, b) [SAL]",
        "description": "Returns a FLONUM value from the Beta distribution. This distribution outputs values between 0 and 1, with outputs more likely to be close to 0 or 1. The parameter a controls the height (probability) of the right side of the distribution (at 1) and b controls the height of the left side (at 0). The distribution is symmetric about 1/2 when a = b."
    },
    "bernoulli-dist": {
        "function": "bernoulli-dist(px1 [, x1, x2]) [SAL]",
        "description": "Returns either x1 (default value is 1) with probability px1 or x2 (default value is 0) with probability 1 - px1. The value of px1 should be between 0 and 1. By convention, a result of x1 is viewed as a success while x2 is viewed as a failure."
    },
    "binomial-dist": {
        "function": "binomial-dist(n, p) [SAL]",
        "description": "Returns a FIXNUM value from the binomial distribution, where n is the number of Bernoulli trials run (a FIXNUM) and p is the probability of success in the Bernoulli trial (a FLONUM from 0 to 1). The mean is the product of n and p."
    },
    "geometric-dist": {
        "function": "geometric-dist(p) [SAL]",
        "description": "Returns a FIXNUM value from the geometric distribution, which is defined as the number of failures before a success is achieved in a Bernoulli trial with probability of success p (a FLONUM from 0 to 1)."
    },
    "poisson-dist": {
        "function": "poisson-dist(delta) [SAL]",
        "description": "Returns a FIXNUM value from the Poisson distribution with a mean of delta (a FIXNUM). The Poisson distribution is often used to generate a sequence of time intervals, resulting in random but often pleasing rhythms."
    },
    "score-gen": {
        "function": "score-gen(k1: e1, k2: e2, ...) [SAL]",
        "description": "where the k's are keywords and the e's are expressions. A score is generated by evaluating the expressions once for each note and constructing a list of keyword-value pairs. A number of keywords have special interpretations. The rules for interpreting these parameters will be explained through a set of questions and answers below."
    },
    "event-time": {
        "function": "event-time(event) [SAL]",
        "description": "Retrieve the time field from an event."
    },
    "event-set-time": {
        "function": "event-set-time(event, time) [SAL]",
        "description": "Construct a new event where the time of event is replaced by time."
    },
    "event-dur": {
        "function": "event-dur(event) [SAL]",
        "description": "Retrieve the duration (i.e. the stretch factor) field from an event."
    },
    "event-set-dur": {
        "function": "event-set-dur(event, dur) [SAL]",
        "description": "Construct a new event where the duration (or stretch factor) of event is replaced by dur."
    },
    "event-expression": {
        "function": "event-expression(event) [SAL]",
        "description": "Retrieve the expression field from an event."
    },
    "event-set-expression": {
        "function": "event-set-expression(event, dur) [SAL]",
        "description": "Construct a new event where the expression of event is replaced by expression."
    },
    "event-end": {
        "function": "event-end(event) [SAL]",
        "description": "Retrieve the end time of event, its time plus its duration."
    },
    "expr-has-attr": {
        "function": "expr-has-attr(expression, attribute) [SAL]",
        "description": "Test whether a score event expression has the given attribute."
    },
    "expr-get-attr": {
        "function": "expr-get-attr(expression, attribute [, default]) [SAL]",
        "description": "Get the value of the given attribute from a score event expression. If attribute is not present, return default if specified, and otherwise nil."
    },
    "expr-set-attr": {
        "function": "expr-set-attr(expr, attribute, value) [SAL]",
        "description": "Construct a new expression identical to expr except that the attribute has value."
    },
    "event-has-attr": {
        "function": "event-has-attr(event, attribute) [SAL]",
        "description": "Test whether a given score event's expression has the given attribute."
    },
    "event-get-attr": {
        "function": "event-get-attr(event, attribute, [default]) [SAL]",
        "description": "Get the value of the given attribute from a score event's expression. If attribute is not present, return default if specified, and otherwise nil."
    },
    "event-set-attr": {
        "function": "event-set-attr(event, attribute, value) [SAL]",
        "description": "Construct a new event identical to event except that the attribute has value."
    },
    "score-sorted": {
        "function": "score-sorted(score) [SAL]",
        "description": "Test if score is sorted."
    },
    "score-sort": {
        "function": "score-sort(score [, copy-flag]) [SAL]",
        "description": "Sort the notes in a score into start-time order. If copy-flag is nil, this is a destructive operation which should only be performed if the top-level score list is a fresh copy that is not shared by any other variables. (The copy-flag is intended for internal system use only.) For the following operations, it is assumed that scores are sorted, and all operations return a sorted score."
    },
    "score-shift": {
        "function": "score-shift(score, offset, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Add a constant offset to the starting time of a set of notes in score. By default, all notes are modified, but the range of notes can be limited with the keyword parameters. The begin time of the score is decreased if necessary to the minimum time of any event that is moved to an earlier time (by a negative offset), and the end time of the score is increased if necessary to the maximum end time of any event that is moved to a later time. If all shifted events remain within the score's begin-to-end range, the begin and end times are not changed. The original score is not modified, and a new score is returned."
    },
    "score-stretch": {
        "function": "score-stretch(score, factor, dur: dur-flag, time: time-flag, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Stretch note times and durations by factor. The default dur-flag is non-null, but if dur-flag is null, the original durations are retained and only times are stretched. Similarly, the default time-flag is non-null, but if time-flag is null, the original times are retained and only durations are stretched. If both dur-flag and time-flag are null, the score is not changed. If a range of notes is specified, times are scaled within that range, and notes after the range are shifted so that the stretched region does not create a 'hole' or overlap with notes that follow. If the range begins or ends with a time (via from-time: and to-time:), time stretching takes place over the indicated time interval independent of whether any notes are present or where they start. In other words, the “rests” are stretched along with the notes. The original score is not modified, and a new score is returned."
    },
    "score-transpose": {
        "function": "score-transpose(score, keyword, amount, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "For each note in the score and in any indicated range, if there is a keyword parameter matching keyword and the parameter value is a number, increment the parameter value by amount. For example, to tranpose up by a whole step, write (score-transpose 2 :pitch score). The original score is not modified, and a new score is returned. If keyword is :pitch and a corresponding parameter value is a list, each element of the list is incremented by amount. This special case is in keeping with the convention of timed-seq in which score events with lists for the :pitch attribute are expanded into 'chords' by instantiating an event for each element (pitch) in the list (chord)."
    },
    "score-scale": {
        "function": "score-scale(score, keyword, amount, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "For each note in the score and in any indicated range, if there is a keyword parameter matching keyword and the parameter value is a number, multiply the parameter value by amount. The original score is not modified, and a new score is returned."
    },
    "score-sustain": {
        "function": "score-sustain(score, factor, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "For each note in the score and in any indicated range, multiply the duration (stretch factor) by amount. This can be used to make notes sound more legato or staccato, and does not change their starting times. The original score is not modified, and a new score is returned."
    },
    "score-voice": {
        "function": "score-voice(score, replacement-list, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "For each note in the score and in any indicated range, replace the behavior (function) name using replacement-list, which has the format: ((old1 new1) (old2 new2) ...), where oldi indicates a current behavior name and newi is the replacement. If oldi is *, it matches anything. For example, to replace my-note-1 by trombone and my-note-2 by horn, use score-voice(score, {{my-note-1 trombone} {my-note-2 horn}}). To replace all instruments with piano, use score-voice(score, {{* piano}}). The original score is not modified, and a new score is returned."
    },
    "score-merge": {
        "function": "score-merge(score1, score2, ...) [SAL]",
        "description": "Create a new score containing all the notes of the parameters, which are all scores. The resulting notes retain their original times and durations. The merged score begin time is the minimum of the begin times of the parameters and the merged score end time is the maximum of the end times of the parameters. The original scores are not modified, and a new score is returned."
    },
    "score-append": {
        "function": "score-append(score1, score2, ...) [SAL]",
        "description": "Create a new score containing all the notes of the parameters, which are all scores. The begin time of the first score is unaltered. The begin time of each other score is aligned to the end time of the previous score; thus, scores are “spliced” in sequence. The original scores are not modified, and a new score is returned."
    },
    "score-select": {
        "function": "score-select(score, predicate, from-index: i, to-index: j, from-time: x, to-time: y, reject: flag, extract: ex) [SAL]",
        "description": "Select (or reject) notes to form a new score. Notes are selected if they fall into the given ranges of index and time and they satisfy predicate, a function of three parameters that is applied to the start time, duration, and the expression of the note. Alternatively, predicate may be t, indicating that all notes in range are to be selected. Note that from-index: i and to-index: j are 1-based: A value of 1 refers to the first note, etc., because the zeroth element of the score is a SCORE-BEGIN-END event. For consistency, if a SCORE-BEGIN-END event is missing from score, one is inserted before any further processing. The selected notes are combined to form a new score. By default, ex, the value of the extract: keyword, is false, and the begin and end markers are retained from score. Conceptually, the score and its timing are retained as an object, but only some of its constituent sound events are retained. Otherwise, if ex is true (non-nil), the begin and end times are computed based on the selected (extracted) events: The begin time is from-time x, if present, and otherwise the time of the first event (if any), and otherwise the begin time of score. Similarly, the end time is the to-time y, if present, and otherwise the end time of the last event (if any), and otherwise the new start time. Alternatively, if the reject: parameter is non-null, the notes not selected form the new score. In other words the selected notes are rejected or removed to form the new score. The begin and end times of score are retained and the extract parameter (ex) is ignored. In all cases, the original score is not modified, and a new score is returned."
    },
    "score-set-begin": {
        "function": "score-set-begin(score, time) [SAL]",
        "description": "The begin time from the score's SCORE-BEGIN-END marker is set to time. The original score is not modified, and a new score is returned."
    },
    "score-get-begin": {
        "function": "score-get-begin(score) [SAL]",
        "description": "Return the begin time of the score."
    },
    "score-set-end": {
        "function": "score-set-end(score, time) [SAL]",
        "description": "The end time from the score's SCORE-BEGIN-END marker is set to time. The original score is not modified, and a new score is returned."
    },
    "score-get-end": {
        "function": "score-get-end(score) [SAL]",
        "description": "Return the end time of the score."
    },
    "score-must-have-begin-end": {
        "function": "score-must-have-begin-end(score) [SAL]",
        "description": "If score does not have a begin and end time, construct a score with a SCORE-BEGIN-END expression and return it. If score already has a begin and end time, just return the score. The orignal score is not modified."
    },
    "score-filter-length": {
        "function": "score-filter-length(score, cutoff) [SAL]",
        "description": "Remove notes that extend beyond the cutoff time. This is similar to score-select, but the here, events are removed when their nominal ending time (start time plus duration) exceeds the cutoff, whereas the to-time: parameter is compared to the note's start time. The original score is not modified, and a new score is returned."
    },
    "score-repeat": {
        "function": "score-repeat(score, n) [SAL]",
        "description": "Make a sequence of n copies of score. Each copy is shifted to that it's begin time aligns with the end time of the previous copy, as in score-append. The original score is not modified, and a new score is returned."
    },
    "score-stretch-to-length": {
        "function": "score-stretch-to-length(score, length) [SAL]",
        "description": "Stretch the score so that the end time of the score is the score's begin time plus length. The original score is not modified, and a new score is returned."
    },
    "score-filter-overlap": {
        "function": "score-filter-overlap(score) [SAL]",
        "description": "Remove overlapping notes (based on the note start time and duration), giving priority to the positional order within the note list (which is also time order). The original score is not modified, and a new score is returned."
    },
    "score-print": {
        "function": "score-print(score, [lines]) [SAL]",
        "description": "Print a score with one note per line. Returns nil. If lines (optional FIXNUM) is given, print a maximum of that many lines (but the minimum is at least 3). The format is first lines-2 score events, the line '...', and the last score event."
    },
    "score-play": {
        "function": "score-play(score) [SAL]",
        "description": "Play score using timed-seq to convert the score to a sound, and play to play the sound."
    },
    "score-adjacent-events": {
        "function": "score-adjacent-events(score, function, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Call (function A B C), where A, B, and C are consecutive notes in the score. The result replaces B. If the result is nil, B is deleted, and the next call will be (function A C D), etc. The first call is to (function nil A B) and the last is to (function Y Z nil). If there is just one note in the score, (function nil A nil) is called. Function calls are not made if the note is outside of the indicated range. This function allows notes and their parameters to be adjusted according to their immediate context. The original score is not modified, and a new score is returned."
    },
    "score-apply": {
        "function": "score-apply(score, function, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Replace each note in the score with the result of (function time dur expression) (in Lisp) or function(time, dur, expression) (in SAL), where time, dur, and expression are the time, duration, and expression of the note. If a range is indicated, only notes in the range are replaced. The original score is not modified, and a new score is returned."
    },
    "score-indexof": {
        "function": "score-indexof(score, function, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Return the index (position) of the first score event (in range) for which applying function using (function time dur expression) returns true."
    },
    "score-last-indexof": {
        "function": "score-last-indexof(score, function, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Return the index (position) of the last score event (in range) for which applying function using (function time dur expression) returns true."
    },
    "score-randomize-start": {
        "function": "score-randomize-start(score, amt, from-index: i, to-index: j, from-time: x, to-time: y) [SAL]",
        "description": "Alter the start times of notes by a random amount up to plus or minus amt. The original score is not modified, and a new score is returned."
    },
    "score-read-smf": {
        "function": "score-read-smf(filename) [SAL]",
        "description": "Read a standard MIDI file from filename. Return an Xmusic score, or nil if the file could not be opened. The start time is zero, and the end time is the maximum end time of all notes. A very limited interface is offered to extract MIDI program numbers from the file: The global variable *rslt* is set to a list of MIDI program numbers for each channel. E.g. if *rslt* is (0 20 77), then program for channel 0 is 0, for channel 1 is 20, and for channel 2 is 77. Program changes were not found on other channels. The default program number is 0, so in this example, it is not known whether the program 0 on channel 0 is the result of a real MIDI program change command or just a default value. If more than one program change exists on a channel, the last program number is recorded and returned, so this information will only be completely correct when the MIDI file sends single program change per channel before any notes are played. This, however, is a fairly common practice. Note that the list returned as *rslt* can be passed to score-write-smf, described below."
    },
    "score-read": {
        "function": "score-read(filename) [SAL]",
        "description": "Read an Adagio file from filename. Return an Xmusic score, or nil if the file could not be opened. See Chapter MIDI, Adagio, and Sequences for details on Adagio, a text-based score language. See score-read-smf for details on handling program changes."
    },
    "score-from-seq": {
        "function": "score-from-seq(seq, prog: pflag, synths: synths, bend: bend, cpress: cpress, ctrl: ctrls) [SAL]",
        "description": "Produce a score from a sequence (see Section The SEQ Type) type seq. The optional pflag, if non-null, will insert program changes as event :prog attributes in score events. The bend and cpress (channel pressure) values may be :onset to introduce :bend or :cpress attributes into score events, or :contin to encode these MIDI messages as SOUNDs available through event :contin attributes. The ctrl parameter is a list where the first element is either :onset or :contin and the remaining elements are controller numbers to be encoded. In all cases :contin values appear in score events as an object. You can access the SOUNDs that encode control changes using the functions ctrlfn-bend(contin), ctrlfn-cpress(contin) or ctrlfn-ctrl(contin, number), which will return const(0) if no corresponding MIDI messages were found. (As a special case the default for controller 7 (volume pedal) is const(1)). See lib/midi/midi_tutorial.htm for more details and code examples. To test for the presence of MIDI messages and avoid the construction of const(0), use ctrlfn-bend?(contin), ctrlfn-cpress?(contin) or ctrlfn-ctrl?(contin, number)."
    },
    "score-write-smf": {
        "function": "score-write-smf(score, filename, [programs as-adagio]) [SAL]",
        "description": "Write a standard MIDI file to filename with notes in score. In this function, every event in the score with a pitch: attribute, regardless of the “instrument” (or function name), generates a MIDI note, using the chan: attribute for the channel (default 0) and the vel: attribute for velocity (default 100). There is no facility (in the current implementation) to issue control changes, but to allow different instruments, MIDI programs may be set in two ways. The simplest is to associate programs with channels using the optional programs parameter, which is simply a list of up to 16 MIDI program numbers. Corresponding program change commands are added to the beginning of the MIDI file. If programs has less than 16 elements, program change commands are only sent on the first n channels. The second way to issue MIDI program changes is to add a program: keyword parameter to a note in the score. Typically, the note will have a pitch: of nil so that no actual MIDI note-on message is generated. If program changes and notes have the same starting times, their relative playback order is undefined, and the note may be cut off by an immediately following program change. Therefore, program changes should occur slightly, e.g. 1 ms, before any notes. Program numbers and channels are numbered starting at zero, matching the internal MIDI representation. This may be one less than displayed on MIDI hardware, sequencers, etc. The as-adagio optional parameter should normally be omitted. If non-nil, the file is written in Adagio format, but if you want to do that, call score-write instead. Xmusic scores do not specify tempo, so the MIDI file is written with a fixed tempo of 100bpm. If you create scores or stretch scores so that each beat is exactly 0.6s (100bpm), sequencers and score editors will quantize your scores correctly. Otherwise, the timing will be correct, but for example a score with one note every second will be notated as 1 note every 1 2/3 beats."
    },
    "score-write": {
        "function": "score-write(score, filename, [programs, absolute]) [SAL]",
        "description": "Write an Adagio format file to filename with notes in score, using absolute times if absolute is true, otherwise write relative times (the default). See Chapter MIDI, Adagio, and Sequences for details on Adagio, a text-based score language. See score-write-smf for details on MIDI program changes."
    },
    "add-to-workspace": {
        "function": "add-to-workspace(symbol) [SAL]",
        "description": "Adds a global variable to the workspace. The symbol should be a (quoted) symbol."
    },
    "save-workspace": {
        "function": "save-workspace() [SAL]",
        "description": "All global variables in the workspace are saved to workspace.lsp (in the current directory), overwriting the previous file."
    },
    "describe": {
        "function": "describe(symbol [, description]) [SAL]",
        "description": "If description, a text string, is present, associate description with the variable named by the symbol. If symbol is not already in the workspace, it is added. If description is omitted, the function returns the current description (from a previous call) for symbol."
    },
    "add-action-to-workspace": {
        "function": "add-action-to-workspace(symbol) [SAL]",
        "description": "Requests that the function named by symbol be called when the workspace is loaded (if the function is defined)."
    },
    "patternp": {
        "function": "patternp(expression) [SAL]",
        "description": "Test if expression is an Xmusic pattern."
    },
    "params-transpose": {
        "function": "params-transpose(params, keyword, amount) [SAL]",
        "description": "Add a transposition amount to a score event parameter. The params parameter is a list of keyword/value pairs (not preceded by a function name). The keyword is the keyword of the value to be altered, and amount is a number to be added to the value. If no matching keyword is present in params, then params is returned. Otherwise, a new parameter list is constructed and returned. The original params is not changed."
    },
    "params-scale": {
        "function": "params-scale(params, keyword, amount) [SAL]",
        "description": "Scale a score event parameter by some factor. This is like params-transpose, only using multiplication. The params list is a list of keyword/value pairs, keyword is the parameter keyword, and amount is the scale factor."
    },
    "interpolate": {
        "function": "interpolate(x, x1, y1, x2, y2) [SAL]",
        "description": "Linearly interpolate (or extrapolate) between points (x1, y1) and (x2, y2) to compute the y value corresponding to x."
    },
    "intersection": {
        "function": "intersection(a, b) [SAL]",
        "description": "Compute the set intersection of lists a and b."
    },
    "union": {
        "function": "union(a, b) [SAL]",
        "description": "Compute the set union of lists a and b."
    },
    "set-difference": {
        "function": "set-difference(a, b) [SAL]",
        "description": "Compute the set of all elements that are in a but not in b."
    },
    "subsetp": {
        "function": "subsetp(a, b) [SAL]",
        "description": "Returns true iff a is a subset of b, that is, each element of a is a member of b."
    }
}
